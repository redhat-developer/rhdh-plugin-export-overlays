name: Pull Request Actions
on:
  issue_comment:
    types: [created, edited]
  pull_request_target:
    types: [opened, synchronize, reopened]

env:
  GH_TEAM: rhdh
  GH_ORGANIZATION: redhat-developer

jobs:
  generate_token:
    runs-on: ubuntu-latest
    name: Generate App Token
    if: github.event.issue.pull_request || github.event_name == 'pull_request_target'
    outputs:
      token: ${{ steps.app-token.outputs.token }}
    steps:
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@67018539274d69449ef7c02e8e71183d1719ab42 # v2.1.4
        with:
          app-id: ${{ secrets.RHDH_GITHUB_APP_ID }}
          private-key: ${{ secrets.RHDH_GITHUB_APP_PRIVATE_KEY }}

  check_authorization:
    runs-on: ubuntu-latest
    name: Verify Authorization
    needs:
      - generate_token
    if: github.event.issue.pull_request || github.event_name == 'pull_request_target'
    outputs:
      is_authorized: ${{ steps.check-internal.outputs.is_internal || steps.check-membership.outputs.is_authorized }}
      reason: ${{ steps.check-internal.outputs.reason || steps.check-membership.outputs.reason }}
      user: ${{ steps.determine-user.outputs.user }}
    steps:
      - name: Determine user to check
        id: determine-user
        run: |
          if [ "${{ github.event_name }}" == "pull_request_target" ]; then
            echo "user=${{ github.event.pull_request.user.login }}" >> $GITHUB_OUTPUT
          else
            echo "user=${{ github.event.comment.user.login }}" >> $GITHUB_OUTPUT
          fi

      - name: Check if internal PR from local branch
        id: check-internal
        # Don't perform this check for issue comments since that would defeat the purpose of the check
        if: github.event_name == 'pull_request_target'
        env:
          PR_REPO: ${{ github.event.pull_request.head.repo.full_name }}
          BASE_REPO: ${{ github.repository }}
        run: |
          if [ "$PR_REPO" == "$BASE_REPO" ]; then
            echo "✓ Internal PR (not from fork) - auto-authorized"
            echo "is_internal=true" >> $GITHUB_OUTPUT
            echo "reason=Internal PR from same repository" >> $GITHUB_OUTPUT
          else
            echo "External PR from fork - will check team membership"
          fi

      - name: Checkout repository
        if: steps.check-internal.outputs.is_internal != 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'pull_request_target' && github.event.pull_request.base.ref || github.base_ref }}

      - name: Check team membership
        id: check-membership
        if: steps.check-internal.outputs.is_internal != 'true'
        uses: ./.github/actions/check-team-membership
        with:
          user: ${{ steps.determine-user.outputs.user }}
          organization: ${{ env.GH_ORGANIZATION }}
          team: ${{ env.GH_TEAM }}
          github_token: ${{ needs.generate_token.outputs.token }}

  parse:
    runs-on: ubuntu-latest
    name: Parse PR Comment
    needs:
      - check_authorization
    if: |
      github.event.issue.pull_request &&
      needs.check_authorization.outputs.is_authorized == 'true'
    outputs:
      command_name: ${{ steps.extract.outputs.command_name }}
      error_message: ${{ steps.extract.outputs.error_message }}
    steps:
      - name: Extract command from comment
        id: extract
        uses: actions/github-script@v7
        with:
          script: |
            const raw = context.payload.comment?.body ?? '';
            
            const lines = String(raw)
              .split(/\r?\n/)
              .map(l => l.trim())
              .filter(l => l.length > 0);
            const allowed = new Set(['/publish', '/update-versions', '/update-commit', '/test']);
            const matchingCommands = lines.filter(l => allowed.has(l));
            
            if (matchingCommands.length > 1) {
              const errorMsg = `Multiple commands found in comment: ${matchingCommands.join(', ')}. Please use only one command per comment.`;
              core.setOutput('error_message', errorMsg);
              core.setOutput('command_name', '');
              core.setFailed(errorMsg);
              return;
            }
            if (matchingCommands.length === 0) {
              core.notice('No command found in comment – cancelling workflow run');
              await github.rest.actions.cancelWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: context.runId,
              });
              return;
            }
            
            const firstMatching = matchingCommands[0] || '';
            core.setOutput('command_name', firstMatching.startsWith('/') ? firstMatching.slice(1) : firstMatching);
            core.setOutput('error_message', '');

  add_error_comment:
    runs-on: ubuntu-latest
    needs:
      - check_authorization
      - parse

    concurrency:
      group: add_error_comment-${{ github.ref_name }}-${{ github.event.issue.number }}
      cancel-in-progress: false

    permissions:
      pull-requests: write

    if: |
      !cancelled() && (
        (github.event.issue.pull_request && needs.parse.outputs.error_message != '') ||
        (github.event.issue.pull_request && needs.check_authorization.outputs.is_authorized != 'true') ||
        (github.event_name == 'pull_request_target' && needs.check_authorization.outputs.is_authorized != 'true')
      )
    steps:
      - name: Add error comment
        uses: actions/github-script@v7
        env:
          INPUT_ERROR_MESSAGE: ${{ needs.parse.outputs.error_message }}
          INPUT_USER: ${{ needs.check_authorization.outputs.user }}
          INPUT_IS_AUTHORIZED: ${{ needs.check_authorization.outputs.is_authorized }}
          INPUT_REASON: ${{ needs.check_authorization.outputs.reason }}
        with:
          script: |
            const errorMessage = core.getInput('error_message');
            const user = core.getInput('user');
            const isAuthorized = core.getInput('is_authorized');
            const reason = core.getInput('reason');
            const isPR = context.eventName === 'pull_request_target';
            const prNumber = isPR 
              ? context.payload.pull_request.number 
              : context.issue.number;
            
            let body = '';
            
            if (errorMessage) {
              body = `**Error**: ${errorMessage}\n\nValid commands are:\n- \`/publish\` - Publish dynamic plugin images\n- \`/update-versions\` - Update versions from release branch\n- \`/update-commit\` - Update commit from automatic discovery\n- \`/test\` - Run integration tests`;
            } else if (isAuthorized !== 'true') {
              if (isPR) {
                body = `**Auto-publish skipped**: PR author \`${user}\` is not a member of the \`${process.env.GH_TEAM}\` team.\n\n`;
                body += `A team member can trigger a build by commenting \`/publish\` on this PR.\n\n`;
              } else {
                body = `**Unauthorized**: User \`${user}\` is not authorized to run PR commands.\n\n`;
                body += `To use PR commands, you must be an active member of the \`${process.env.GH_TEAM}\` team in the \`${process.env.GH_ORGANIZATION}\` organization.\n\n`;
              }
              body += `Reason: ${reason}`;
            }
            
            if (body) {
              await github.rest.issues.createComment({
                issue_number: prNumber,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body
              });
            }

  prepare:
    runs-on: ubuntu-latest
    name: Prepare PR Context
    needs:
      - check_authorization
      - parse

    concurrency:
      group: prepare-${{ github.ref_name }}-${{ github.event.issue.number }}
      cancel-in-progress: false
    outputs:
      target-branch: ${{ steps.get-branch.outputs.target-branch }}
      overlay-branch: ${{ steps.get-branch.outputs.overlay-branch }}
      overlay-repo: ${{ steps.get-branch.outputs.overlay-repo }}
      overlay-commit: ${{ steps.get-branch.outputs.overlay-commit }}
      workspace: ${{ steps.get-branch.outputs.workspace }}
      pr-number: ${{ steps.get-branch.outputs.pr-number }}
      status-context: ${{ steps.get-branch.outputs.status-context }}

    permissions:
      statuses: write

    if: |
      !cancelled() &&
      needs.check_authorization.outputs.is_authorized == 'true' &&
      (needs.parse.outputs.command_name != '' || github.event_name == 'pull_request_target')
    steps:
      - name: Get PR branch data
        id: get-branch
        uses: actions/github-script@v7
        env:
          INPUT_COMMAND_NAME: ${{ needs.parse.outputs.command_name }}
        with:
          script: |
            const isPrEvent = context.eventName === 'pull_request_target';
            const prNumber = isPrEvent 
              ? context.payload.pull_request.number 
              : context.issue.number;
            const statusContext = isPrEvent ? 'auto-publish' : core.getInput('command_name');
            
            core.setOutput('status-context', statusContext);
            
            const currentPullRequest = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            const targetBranch = currentPullRequest.data.base.ref;
            core.setOutput('target-branch', targetBranch);

            const prBranch = currentPullRequest.data.head.ref;
            core.setOutput('overlay-branch', prBranch);
            
            const prRepo = currentPullRequest.data.head.repo.full_name;
            core.setOutput('overlay-repo', prRepo);
            
            core.setOutput('pr-number', prNumber);

            const prCommit = currentPullRequest.data.head.sha;
            core.setOutput('overlay-commit', prCommit);
            
            let workspace = '';

            const matches = prBranch.match(/^workspaces\/release-.+__(.+)$/);
            if (matches && matches.length == 2) {
              workspace = `workspaces/${matches[1]}`;
            } else {
              const prFiles = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              const workspaces = [ ... new Set(prFiles.data
                .map(f => f.filename.match(/^workspaces\/([^\/]+)\/.*/))
                .filter(match => match)
                .map(match => match[1])
              )];
              if (workspaces.length === 1) {
                workspace = `workspaces/${workspaces[0]}`;
              }
            }
            
            core.setOutput('workspace', workspace);

            if (workspace === '') {
              return;
            }

            const workflowRun = await github.rest.actions.getWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: '${{ github.run_id }}',
            });
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: prCommit,
              description: '${{ github.workflow }}',
              state: 'pending',
              target_url: workflowRun.data.html_url,
              context: statusContext
            });

  export:
    name: Publish PR Dynamic Plugin Images
    needs:
      - check_authorization
      - parse
      - prepare
      - checkPRUpToDate

    concurrency:
      group: export-${{ github.ref_name }}-${{ github.event.issue.number }}
      cancel-in-progress: true

    if: |
      !cancelled() &&
      needs.check_authorization.outputs.is_authorized == 'true' &&
      needs.prepare.outputs.workspace != '' &&
      (needs.parse.outputs.command_name == 'publish' || github.event_name == 'pull_request_target')

    uses: redhat-developer/rhdh-plugin-export-utils/.github/workflows/export-workspaces-as-dynamic.yaml@main
    with:
      overlay-branch: ${{ needs.prepare.outputs.overlay-branch }}
      overlay-repo: ${{ needs.prepare.outputs.overlay-repo }}
      workspace-path: ${{ needs.prepare.outputs.workspace }}
      publish-container: true
      image-repository-prefix: ${{ format('ghcr.io/{0}', github.repository) }}
      image-tag-prefix: ${{ format('pr_{0}__', needs.prepare.outputs.pr-number) }}
      image-registry-user: ${{ github.actor }}

    secrets:
      image-registry-password: ${{ secrets.GITHUB_TOKEN }}

    permissions:
      contents: write
      attestations: write
      packages: write
      id-token: write

  uploadPublishedExportsArtifact:
    name: Upload published-exports artifact
    needs:
      - check_authorization
      - parse
      - prepare
      - export

    concurrency:
      group: uploadPublishedExportsArtifact-${{ github.ref_name }}-${{ github.event.issue.number }}
      cancel-in-progress: false

    if: |
      !cancelled() &&
      needs.check_authorization.outputs.is_authorized == 'true' &&
      needs.prepare.outputs.workspace != '' &&
      (needs.parse.outputs.command_name == 'publish' || github.event_name == 'pull_request_target') &&
      needs.export.outputs.published-exports != ''
    runs-on: ubuntu-latest
    steps:
      - name: Write and stage meta.json
        env:
          WORKSPACE: ${{ needs.prepare.outputs.workspace }}
          OVERLAY_BRANCH: ${{ needs.prepare.outputs.overlay-branch }}
          OVERLAY_REPO: ${{ needs.prepare.outputs.overlay-repo }}
          OVERLAY_COMMIT: ${{ needs.prepare.outputs.overlay-commit }}
          PR_NUMBER: ${{ needs.prepare.outputs.pr-number }}
        run: |
          mkdir -p published-exports
          cat > published-exports/meta.json <<EOF
          {"workspace":"${WORKSPACE}","overlayBranch":"${OVERLAY_BRANCH}","overlayRepo":"${OVERLAY_REPO}","overlayCommit":"${OVERLAY_COMMIT}","pr":${PR_NUMBER}}
          EOF
      - name: Stage published exports content
        env:
          PUBLISHED_EXPORTS: ${{ needs.export.outputs.published-exports }}
        run: |
          printf "%s\n" "$PUBLISHED_EXPORTS" > published-exports/published-exports.txt
      - name: Upload published-exports artifact
        uses: actions/upload-artifact@v4
        with:
          name: published-exports
          path: published-exports/
          if-no-files-found: error
          retention-days: 7
      - name: Upload context artifact
        uses: actions/upload-artifact@v4
        with:
          name: context-${{ github.run_id }}
          path: published-exports/meta.json
          if-no-files-found: error
          retention-days: 1

  create_test_context:
    runs-on: ubuntu-latest
    name: Create Test Context
    needs:
      - check_authorization
      - parse
      - prepare

    if: |
      needs.parse.outputs.command_name == 'test' &&
      needs.check_authorization.outputs.is_authorized == 'true' &&
      needs.prepare.outputs.pr-number != ''
    steps:
      - name: Write meta.json for test context
        env:
          WORKSPACE: ${{ needs.prepare.outputs.workspace }}
          OVERLAY_BRANCH: ${{ needs.prepare.outputs.overlay-branch }}
          OVERLAY_REPO: ${{ needs.prepare.outputs.overlay-repo }}
          OVERLAY_COMMIT: ${{ needs.prepare.outputs.overlay-commit }}
          PR_NUMBER: ${{ needs.prepare.outputs.pr-number }}
        run: |
          mkdir -p context
          cat > context/meta.json <<EOF
          {"workspace":"${WORKSPACE}","overlayBranch":"${OVERLAY_BRANCH}","overlayRepo":"${OVERLAY_REPO}","overlayCommit":"${OVERLAY_COMMIT}","pr":${PR_NUMBER}}
          EOF
      - name: Upload test-context artifact
        uses: actions/upload-artifact@v4
        with:
          name: context-${{ github.run_id }}
          path: context/meta.json
          if-no-files-found: error
          retention-days: 1

  checkBackstageCompatibility:
    name: Check workspace backstage compatibility
    needs:
      - check_authorization
      - parse
      - prepare
      - checkPRUpToDate

    concurrency:
      group: checkBackstageCompatibility-${{ github.ref_name }}-${{ github.event.issue.number }}
      cancel-in-progress: true

    if: |
      !cancelled() &&
      needs.check_authorization.outputs.is_authorized == 'true' &&
      needs.prepare.outputs.workspace != '' &&
      (needs.parse.outputs.command_name == 'publish' || github.event_name == 'pull_request_target')

    uses: redhat-developer/rhdh-plugin-export-utils/.github/workflows/check-backstage-compatibility.yaml@main
    with:
      overlay-branch: ${{ needs.prepare.outputs.overlay-branch }}
      overlay-repo: ${{ needs.prepare.outputs.overlay-repo }}
      workspace-path: ${{ needs.prepare.outputs.workspace }}

  add_publish_completion_comment:
    runs-on: ubuntu-latest
    needs:
      - check_authorization
      - parse
      - prepare
      - checkPRUpToDate
      - export
      - checkBackstageCompatibility

    concurrency:
      group: add_publish_completion_comment-${{ github.ref_name }}-${{ github.event.issue.number }}
      cancel-in-progress: false

    permissions:
      statuses: write
      pull-requests: write

    if: |
      !cancelled() &&
      needs.check_authorization.outputs.is_authorized == 'true' &&
      needs.prepare.outputs.workspace != '' &&
      needs.prepare.outputs.overlay-branch != '' &&
      (needs.parse.outputs.command_name == 'publish' || github.event_name == 'pull_request_target')
    steps:
      - name: Download compatibility report
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: backstage-compatibility-report
          path: ./

      - name: Add completion comment
        uses: actions/github-script@v7
        env:
          INPUT_OVERLAY_COMMIT: ${{ needs.prepare.outputs.overlay-commit }}
          INPUT_PUBLISHED_EXPORTS: ${{ needs.export.outputs.published-exports }}
          INPUT_FAILED_EXPORTS: ${{ needs.export.outputs.failed-exports }}
          INPUT_STATUS_CONTEXT: ${{ needs.prepare.outputs.status-context }}
          INPUT_PR_NUMBER: ${{ needs.prepare.outputs.pr-number }}
        with:
          script: |
            const fs = require('fs');
            const prNumber = Number(core.getInput('pr_number'));
            const statusContext = core.getInput('status_context');
            
            const workflowRun = await github.rest.actions.getWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: '${{ github.run_id }}'
            });
            
            const jobs = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: '${{ github.run_id }}',
              filter: 'latest',
            });
            
            const success = jobs.data.jobs
              .filter(j => 
                j.name.startsWith('Publish') || 
                j.name.startsWith('Export') || 
                j.name.startsWith('Check') ||
                j.name.startsWith('export')
              )
              .every(j => j.conclusion === 'success');

            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: core.getInput('overlay_commit'),
              description: '${{ github.workflow }}',
              state: success ? 'success' : 'failure',
              target_url: workflowRun.data.html_url,
              context: statusContext,
            });

            let body = `[Publish workflow](${workflowRun.data.html_url}) has completed with ${ success ? 'success' : 'failure' }.`;
            
            // Check for compatibility report
            const reportPath = 'backstage-compatibility-report.md';
            if (fs.existsSync(reportPath)) {
              const reportContent = fs.readFileSync(reportPath, 'utf8');
              body = `${body}\n\n${reportContent}`;
            }
            
            const publishedExports = core.getMultilineInput('published_exports');
            if (publishedExports.length > 0) {
              body = `${body}\n- Published container images:`;
              publishedExports.forEach(line => {
                body = `${body}\n  - ${line}`;
              });
            }
            
            const failedExports = core.getMultilineInput('failed_exports');
            if (failedExports.length > 0) {
              body = `${body}\n- Plugins failed during export or container image publishing:`;
              failedExports.forEach(line => {
                body = `${body}\n  - ${line}`;
              });
            }
            
            await github.rest.issues.createComment({
              issue_number: prNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

  add_no_workspace_comment:
    runs-on: ubuntu-latest
    needs:
      - check_authorization
      - parse
      - prepare
    permissions:
      statuses: write
      pull-requests: write

    if: |
      !cancelled() &&
      needs.check_authorization.outputs.is_authorized == 'true' &&
      needs.prepare.outputs.overlay-branch != '' &&
      needs.prepare.outputs.workspace == ''
    steps:
      - name: Add skipped comment
        uses: actions/github-script@v7
        env:
          INPUT_OVERLAY_COMMIT: ${{ needs.prepare.outputs.overlay-commit }}
          INPUT_STATUS_CONTEXT: ${{ needs.prepare.outputs.status-context }}
          INPUT_PR_NUMBER: ${{ needs.prepare.outputs.pr-number }}
        with:
          script: |
            const prNumber = Number(core.getInput('pr_number'));
            const statusContext = core.getInput('status_context');
            
            const workflowRun = await github.rest.actions.getWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: '${{ github.run_id }}'
            });

            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: core.getInput('overlay_commit'),
              description: '${{ github.workflow }}',
              state: 'success',
              target_url: workflowRun.data.html_url,
              context: statusContext,
            });

            const body = `[PR action (\`/${core.getInput('command_name')}\`)](${workflowRun.data.html_url}) cancelled: PR doesn't touch only 1 workspace.`;
            await github.rest.issues.createComment({
              issue_number: prNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            })

  checkPRUpToDate:
    runs-on: ubuntu-latest
    name: Checks whether the PR is up-to-date with versions.json
    needs:
      - check_authorization
      - parse
      - prepare

    permissions:
      statuses: write
      pull-requests: write

    if: |
      !cancelled() &&
      needs.check_authorization.outputs.is_authorized == 'true' &&
      needs.prepare.outputs.workspace != '' &&
      (needs.parse.outputs.command_name == 'publish' || github.event_name == 'pull_request_target')
    steps:
      - name: Check versions.json matches release branch
        uses: actions/github-script@v7
        env:
          INPUT_TARGET_BRANCH: ${{ needs.prepare.outputs.target-branch }}
          INPUT_OVERLAY_BRANCH: ${{ needs.prepare.outputs.overlay-branch }}
          INPUT_OVERLAY_REPO: ${{ needs.prepare.outputs.overlay-repo }}
          INPUT_PR_NUMBER: ${{ needs.prepare.outputs.pr-number }}
        with:
          script: |
            const path = 'versions.json';
            const releaseBranch = core.getInput('target_branch');
            const prNumber = Number(core.getInput('pr_number'));
            
            if (!releaseBranch?.startsWith('release-') && !releaseBranch?.startsWith('main')) {
              core.notice(`Current PR is not based on a release branch.`);
              return;
            }
            
            const { data: sourceFile } = await github.rest.repos.getContent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path,
              ref: releaseBranch,
            });
            
            if (!('type' in sourceFile) || sourceFile.type !== 'file') {
              core.setFailed(`\`${path}\` is not a file on branch \`${releaseBranch}\``);
              return;
            }
            
            const sourceContent = Buffer.from(
              sourceFile.content,
              (Buffer.isEncoding(sourceFile.encoding) ? sourceFile.encoding : 'utf-8')
            ).toString('utf-8');
    
            const prRepository = core.getInput('overlay_repo');
            const prBranch = core.getInput('overlay_branch');
            const owner = prRepository.split('/')[0];
            const repo = prRepository.split('/')[1];
            
            const { data: targetFile } = await github.rest.repos.getContent({
              owner,
              repo,
              path,
              ref: prBranch,
            });
            
            if (!('type' in targetFile) || targetFile.type !== 'file') {
              core.warning(`\`${path}\` is not a file on branch ${prBranch}`);
              return;
            }
            
            const targetContent = Buffer.from(
              targetFile.content,
              (Buffer.isEncoding(targetFile.encoding) ? targetFile.encoding : 'utf-8')
            ).toString('utf-8');
      
            if (sourceContent !== targetContent) {
              core.setFailed(`PR not up-to-date with the release branch`);
              const body = `The \`versions.json\` file in your PR doesn't match the one in release branch #${releaseBranch}\nTry updating it by adding the \`/update-versions\` PR comment.`;
              await github.rest.issues.createComment({
                issue_number: prNumber,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body
              });
            }

  updatePRWithVersions:
    name: Update versions on PR from release branch
    needs:
      - check_authorization
      - parse
      - prepare

    concurrency:
      group: updatePRWithVersions-${{ github.ref_name }}-${{ github.event.issue.number }}
      cancel-in-progress: true
    
    if: needs.parse.outputs.command_name == 'update-versions' && needs.check_authorization.outputs.is_authorized == 'true'
    uses: ./.github/workflows/update-prs-with-release-branch-commits.yaml
    with:
      force: true
      pr: ${{ needs.prepare.outputs.pr-number }}
      release-branch: ${{ needs.prepare.outputs.target-branch }}
    permissions:
      contents: write
      pull-requests: write

  add_update_versions_completion_comment:
    runs-on: ubuntu-latest
    needs:
      - check_authorization
      - parse
      - prepare
      - updatePRWithVersions

    concurrency:
      group: add_update_versions_completion_comment-${{ github.ref_name }}-${{ github.event.issue.number }}
      cancel-in-progress: false
    
    permissions:
      statuses: write
      pull-requests: write

    if: |
      !cancelled() &&
      needs.parse.outputs.command_name == 'update-versions' &&
      needs.check_authorization.outputs.is_authorized == 'true' &&
      needs.prepare.outputs.overlay-branch != '' &&
      needs.prepare.outputs.workspace != ''
    steps:
      - name: Add completion comment
        uses: actions/github-script@v7
        env:
          INPUT_OVERLAY_COMMIT: ${{ needs.prepare.outputs.overlay-commit }}
          INPUT_STATUS_CONTEXT: ${{ needs.prepare.outputs.status-context }}
          INPUT_PR_NUMBER: ${{ needs.prepare.outputs.pr-number }}
        with:
          script: |
            const prNumber = Number(core.getInput('pr_number'));
            const statusContext = core.getInput('status_context');
            
            const workflowRun = await github.rest.actions.getWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: '${{ github.run_id }}'
            });
            const jobs = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: '${{ github.run_id }}',
              filter: 'latest',
            });
            const success = jobs.data.jobs
              .filter(j => j.name.startsWith('Update versions on PR'))
              .every(j => j.conclusion === 'success');

            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: core.getInput('overlay_commit'),
              description: '${{ github.workflow }}',
              state: success ? 'success' : 'failure',
              target_url: workflowRun.data.html_url,
              context: statusContext,
            });

            let body = `[Update Versions workflow](${workflowRun.data.html_url}) has completed with ${ success ? 'success' : 'failure' }.`;
            await github.rest.issues.createComment({
              issue_number: prNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            })

  updatePRWithCommit:
    name: Update commit on PR from automatic discovery
    needs:
      - check_authorization
      - parse
      - prepare

    concurrency:
      group: updatePRWithCommit-${{ github.ref_name }}-${{ github.event.issue.number }}
      cancel-in-progress: true
    
    if: | 
      needs.parse.outputs.command_name == 'update-commit' && 
      needs.check_authorization.outputs.is_authorized == 'true'
    uses: ./.github/workflows/update-plugins-repo-refs.yaml
    with:
      single-branch: ${{ needs.prepare.outputs.target-branch }}
      allow-workspace-addition: false
      pr-to-update: ${{ needs.prepare.outputs.pr-number }}
      workspace-path: ${{ needs.prepare.outputs.workspace }}

    permissions:
      contents: write
      pull-requests: write

  add_update_commit_completion_comment:
    runs-on: ubuntu-latest
    needs:
      - check_authorization
      - parse
      - prepare
      - updatePRWithCommit

    concurrency:
      group: add_update_commit_completion_comment-${{ github.ref_name }}-${{ github.event.issue.number }}
      cancel-in-progress: false
    
    permissions:
      statuses: write
      pull-requests: write

    if: |
      !cancelled() &&
      needs.parse.outputs.command_name == 'update-commit' &&
      needs.check_authorization.outputs.is_authorized == 'true' &&
      needs.prepare.outputs.overlay-branch != '' &&
      needs.prepare.outputs.workspace != ''
    steps:
      - name: Add completion comment
        uses: actions/github-script@v7
        env:
          INPUT_OVERLAY_COMMIT: ${{ needs.prepare.outputs.overlay-commit }}
          INPUT_STATUS_CONTEXT: ${{ needs.prepare.outputs.status-context }}
          INPUT_PR_NUMBER: ${{ needs.prepare.outputs.pr-number }}
        with:
          script: |
            const prNumber = Number(core.getInput('pr_number'));
            const statusContext = core.getInput('status_context');
            
            const workflowRun = await github.rest.actions.getWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: '${{ github.run_id }}'
            });
            const jobs = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: '${{ github.run_id }}',
              filter: 'latest',
            });
            const success = jobs.data.jobs
              .filter(j => j.name.startsWith('Update commit on PR'))
              .every(j => j.conclusion === 'success' || j.conclusion === 'skipped');

            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: core.getInput('overlay_commit'),
              description: '${{ github.workflow }}',
              state: success ? 'success' : 'failure',
              target_url: workflowRun.data.html_url,
              context: statusContext,
            });

            let body = `[Update Commit workflow](${workflowRun.data.html_url}) has completed with ${ success ? 'success' : 'failure' }.`;
            await github.rest.issues.createComment({
              issue_number: prNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            })
